doctrine Iface where {
  mode M;
  type A @M;
  gen dup a : [a] -> [a, a] @M;
  gen drop a : [a] -> [] @M;
  gen swap a b : [a, b] -> [b, a] @M;
  gen f : [A] -> [A] @M;
}

doctrine Target extends Iface where {
  gen g : [A] -> [A] @M;
}

implements Iface for Target using Target.fromBase;

surface IfaceSSA where {
  doctrine Iface;
  mode M;

  lexer {
    keywords: diag, in, out;
    symbols: "(", ")", "{", "}", ":", "=", ";", ",";
  }

  expr {
    atom:
      ident "(" <expr> ")" => CALL(name, args)
    | ident => VAR(name)
    | "out" <expr> ";" => OUT(expr)
    | "diag" "{" <expr> "}" => DIAG(expr)
    | "(" <expr> ")" => <expr>
    ;

    prefix:
      "in" ident ":" <type> ";" <expr> => IN(name, ty, body)
    | ident "=" <expr> ";" <expr> => LET(name, val, body)
    ;

    infixr 10 "," => LIST(lhs, rhs);
  }

  elaborate {
    VAR(x) => $x;;
    LIST(a, b) => $1 * $2;;
    OUT(e) => $1;;
    DIAG(e) => $1;;
    IN(x, ty, body) => $1;;
    LET(x, val, body) => $1 * $2;;
  }
}

run main where {
  doctrine Target;
  surface IfaceSSA;
  uses: Iface;
  show normalized;
}
---
diag {
  in x:A;
  out f(x);
}
---
