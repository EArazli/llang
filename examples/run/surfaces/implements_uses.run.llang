doctrine Iface where {
  mode M;
  type A @M;
  gen dup (a@M) : [a] -> [a, a] @M;
  gen drop (a@M) : [a] -> [] @M;
  gen swap (a@M, b@M) : [a, b] -> [b, a] @M;
  gen f : [A] -> [A] @M;
}

doctrine Target extends Iface where {
  gen g : [A] -> [A] @M;
}

implements Iface for Target using Target.fromBase;

surface IfaceSSA where {
  doctrine Iface;
  mode M;

  lexer {
    keywords: diag, in, out;
    symbols: "(", ")", "{", "}", ":", "=", ";", ",";
  }

  expr {
    atom:
      ident(name) "(" <expr> ")" => $1 ; #name
    | ident(name) => $name
    | "out" <expr> ";" => $1
    | "diag" "{" <expr> "}" => $1
    | "(" <expr> ")" => <expr>
    ;

    prefix:
      "in" ident(name) ":" <type>(ty) ";" <expr> => <expr> bind in(name, ty, 1)
    | ident(name) "=" <expr> ";" <expr> => $1 * $2 bind let(name, 1, 2)
    ;

    infixr 10 "," => $1 * $2;
  }
}

pipeline debug where {
  normalize { policy = "topmost"; fuel = 50; };
  extract diagram;
}

run main using debug where {
  source doctrine Target;
  source mode M;
  source surface IfaceSSA;
  uses ["Iface"];
}
---
diag {
  in x:A;
  out f(x);
}
---
