doctrine Staging where {
  mode RT;
  mode CT;

  structure RT = linear;
  structure CT = linear;

  modality quote : RT -> CT;
  modality splice : CT -> RT;
  mod_eq splice.quote -> id@RT;

  type Nat @RT;

  gen stage : [splice(quote(RT.Nat))] -> [splice(quote(RT.Nat))] @RT;
  gen stageq : [quote(RT.Nat)] -> [quote(RT.Nat)] @CT;
}

surface StageExpr where {
  doctrine Staging;
  mode RT;

  lexer {
    keywords: stage;
    symbols: ;
  }

  expr {
    atom:
      "stage" => stage
    ;
  }
}

surface StageExprCT where {
  doctrine Staging;
  mode CT;

  lexer {
    keywords: stageq;
    symbols: ;
  }

  expr {
    atom:
      "stageq" => stageq
    ;
  }
}

doctrine Staging2 where {
  mode R2;
  mode C2;

  structure R2 = linear;
  structure C2 = linear;

  modality Q : R2 -> C2;
  modality S : C2 -> R2;
  mod_eq S.Q -> id@R2;

  type Nat @R2;

  gen stage2 : [S(Q(R2.Nat))] -> [S(Q(R2.Nat))] @R2;
  gen stageq2 : [Q(R2.Nat)] -> [Q(R2.Nat)] @C2;

  rule computational stage2_id -> : [Nat] -> [Nat] @R2 =
    stage2 == id[Nat]
}

morphism StageToStage2 : Staging -> Staging2 where {
  mode RT -> R2;
  mode CT -> C2;
  modality quote -> Q;
  modality splice -> S;
  type Nat @RT -> Nat @R2;
  gen stage @RT -> stage2
  gen stageq @CT -> stageq2
}
