doctrine QuadDiscipline where {
  mode Lin;
  mode Aff;
  mode Rel;
  mode Cart;

  structure Lin = linear;
  structure Aff = affine;
  structure Rel = relevant;
  structure Cart = cartesian;

  type Base @Lin;
  type Base @Aff;
  type Base @Rel;
  type Base @Cart;

  gen pair : [Lin.Base, Lin.Base] -> [Lin.Base] @Lin;
  gen pair : [Aff.Base, Aff.Base] -> [Aff.Base] @Aff;
  gen pair : [Rel.Base, Rel.Base] -> [Rel.Base] @Rel;
  gen pair : [Cart.Base, Cart.Base] -> [Cart.Base] @Cart;

  gen unit : [] -> [Lin.Base] @Lin;
  gen unit : [] -> [Aff.Base] @Aff;
  gen unit : [] -> [Rel.Base] @Rel;
  gen unit : [] -> [Cart.Base] @Cart;

  gen dup (a@Rel) : [a] -> [a, a] @Rel;
  gen dup (a@Cart) : [a] -> [a, a] @Cart;

  gen drop (a@Aff) : [a] -> [] @Aff;
  gen drop (a@Cart) : [a] -> [] @Cart;

  rule structural coassoc_rel = (a@Rel) : [a] -> [a, a, a] @Rel =
    dup ; (dup * id[a]) == dup ; (id[a] * dup)

  rule structural coassoc_cart = (a@Cart) : [a] -> [a, a, a] @Cart =
    dup ; (dup * id[a]) == dup ; (id[a] * dup)

  rule structural counitL_cart = (a@Cart) : [a] -> [a] @Cart =
    dup ; (drop * id[a]) == id[a]

  rule structural counitR_cart = (a@Cart) : [a] -> [a] @Cart =
    dup ; (id[a] * drop) == id[a]
}

surface QuadLin where {
  doctrine QuadDiscipline;
  mode Lin;

  lexer {
    keywords: diag, in, out;
    symbols: "(", ")", "{", "}", ":", ";", ",";
  }

  expr {
    atom:
      ident(name) "(" <expr> ")" => $1 ; #name
    | ident(name) => $name
    | "out" <expr> => $1
    | "diag" "{" <expr> "}" => $1
    | "(" <expr> ")" => <expr>
    ;
    prefix:
      "in" ident(name) ":" <type>(ty) ";" <expr> => <expr> bind in(name, ty, 1)
    ;
    infixr 10 "," => $1 * $2;
  }
}

surface QuadAff where {
  doctrine QuadDiscipline;
  mode Aff;

  lexer {
    keywords: diag, in, out;
    symbols: "(", ")", "{", "}", ":", ";", ",";
  }

  expr {
    atom:
      ident(name) "(" <expr> ")" => $1 ; #name
    | ident(name) => $name
    | "out" <expr> => $1
    | "diag" "{" <expr> "}" => $1
    | "(" <expr> ")" => <expr>
    ;
    prefix:
      "in" ident(name) ":" <type>(ty) ";" <expr> => <expr> bind in(name, ty, 1)
    ;
    infixr 10 "," => $1 * $2;
  }
}

surface QuadRel where {
  doctrine QuadDiscipline;
  mode Rel;

  lexer {
    keywords: diag, in, out;
    symbols: "(", ")", "{", "}", ":", ";", ",";
  }

  expr {
    atom:
      ident(name) "(" <expr> ")" => $1 ; #name
    | ident(name) => $name
    | "out" <expr> => $1
    | "diag" "{" <expr> "}" => $1
    | "(" <expr> ")" => <expr>
    ;
    prefix:
      "in" ident(name) ":" <type>(ty) ";" <expr> => <expr> bind in(name, ty, 1)
    ;
    infixr 10 "," => $1 * $2;
  }
}

surface QuadCart where {
  doctrine QuadDiscipline;
  mode Cart;

  lexer {
    keywords: diag, in, out;
    symbols: "(", ")", "{", "}", ":", ";", ",";
  }

  expr {
    atom:
      ident(name) "(" <expr> ")" => $1 ; #name
    | ident(name) => $name
    | "out" <expr> => $1
    | "diag" "{" <expr> "}" => $1
    | "(" <expr> ")" => <expr>
    ;
    prefix:
      "in" ident(name) ":" <type>(ty) ";" <expr> => <expr> bind in(name, ty, 1)
    ;
    infixr 10 "," => $1 * $2;
  }
}
