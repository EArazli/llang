doctrine JSSSA where {
  mode M;
  attrsort string = string;
  type Expr @M;

  gen strLit {s:string} : [] -> [Expr] @M;
  gen serve : [Expr] -> [] @M;
}

surface JSSSA_Surface where {
  doctrine JSSSA;
  mode M;

  lexer {
    keywords: let, serve;
    symbols: "(", ")", "=", ";";
  }

  expr {
    atom:
      string => STR(s)
    | "serve" "(" <expr> ")" => SERVE(e)
    | ident => VAR(x)
    | "(" <expr> ")" => <expr>
    ;

    prefix:
      "let" ident "=" <expr> ";" <expr> => LET(name, bound, body)
    ;
  }

  elaborate {
    STR(s) => strLit(s=#s);;
    VAR(x) => $x;;
    SERVE(e) => $1 ; serve;;
    LET(name, bound, body) => ($1 * $2);;
  }
}

model JSSSA_Fold : JSSSA where {
  backend = fold_ssa;
  default = error "missing op";
  op strLit(s) = "\"" ++ s ++ "\"";
  op serve(msg) = "Bun.serve({ fetch(req) { return new Response(" ++ msg ++ "); } });";
}
