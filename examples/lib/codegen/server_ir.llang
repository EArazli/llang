doctrine ServerIR where {
  mode M;
  attrsort string = string;
  type Expr @M;

  gen stringLit {s:string} : [] -> [Expr] @M;
  gen concat : [Expr, Expr] -> [Expr] @M;
  gen serve : [Expr] -> [] @M;
}

surface ServerIR_Surface where {
  doctrine ServerIR;
  mode M;

  lexer {
    keywords: let, serve;
    symbols: "(", ")", "=", ";", "+";
  }

  expr {
    atom:
      string => STR(s)
    | "serve" "(" <expr> ")" => SERVE(e)
    | ident => VAR(x)
    | "(" <expr> ")" => <expr>
    ;

    prefix:
      "let" ident "=" <expr> ";" <expr> => LET(name, bound, body)
    ;

    infixl 10 "+" => ADD(lhs, rhs);
  }

  elaborate {
    STR(s) => stringLit(s=#s);;
    VAR(x) => $x;;
    ADD(a, b) => ($1 * $2) ; concat;;
    SERVE(e) => $1 ; serve;;
    LET(name, bound, body) => ($1 * $2);;
  }
}

model ServerJS_Base : ServerIR where {
  backend = fold;
  default = error "missing op";

  fold {
    indent = "  ";
    reserved = ["if", "return", "const", "let", "function"];

    prologue_closed() = "(() => {";
    epilogue_closed() = "})()";

    prologue_open(params, paramDecls) = "(" ++ params ++ ") => {";
    epilogue_open() = "}";

    bind0(stmt) = stmt;
    bind1(out, ty, expr) = "const " ++ out ++ " = " ++ expr ++ ";";
    bindN(outs, decls, expr) = "const [" ++ outs ++ "] = " ++ expr ++ ";";

    return0() = "";
    return1(out, ty) = "return " ++ out ++ ";";
    returnN(outs, decls) = "return [" ++ outs ++ "];";
  }

  op stringLit(s) = "\"" ++ s ++ "\"";
  op concat(a, b) = a ++ " + " ++ b;
}

model ServerJS_Bun : ServerIR using ServerJS_Base where {
  op serve(msg) = "Bun.serve({ fetch(req) { return new Response(" ++ msg ++ "); } });";
}

model ServerJS_Express : ServerIR using ServerJS_Base where {
  op serve(msg) = "const app = require(\"express\")(); app.get(\"/\", (_req, res) => res.send(" ++ msg ++ ")); app.listen(3000);";
}
