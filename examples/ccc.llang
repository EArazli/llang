doctrine CCCore where {
  sort Obj;
  sort Hom(Obj, Obj);

  # Category structure
  op id : (x:Obj) -> Hom(?x, ?x);

  op comp :
    (a:Obj) (b:Obj) (c:Obj)
    (f:Hom(?b, ?c)) (g:Hom(?a, ?b))
    -> Hom(?a, ?c);

  computational idL :
    (a:Obj) (b:Obj) (g:Hom(?a, ?b)) |-
      comp(?a, ?b, ?b, id(?b), ?g) -> ?g;

  computational idR :
    (a:Obj) (b:Obj) (f:Hom(?a, ?b)) |-
      comp(?a, ?a, ?b, ?f, id(?a)) -> ?f;

  computational assoc :
    (a:Obj) (b:Obj) (c:Obj) (d:Obj)
    (h:Hom(?c, ?d)) (g:Hom(?b, ?c)) (f:Hom(?a, ?b)) |-
      comp(?a, ?b, ?d, comp(?b, ?c, ?d, ?h, ?g), ?f)
        -> comp(?a, ?c, ?d, ?h, comp(?a, ?b, ?c, ?g, ?f));

  # Finite products
  op Unit : Obj;

  op prod : (a:Obj) (b:Obj) -> Obj;

  op terminal : (a:Obj) -> Hom(?a, Unit);

  op exl : (a:Obj) (b:Obj) -> Hom(prod(?a, ?b), ?a);
  op exr : (a:Obj) (b:Obj) -> Hom(prod(?a, ?b), ?b);

  op pair :
    (a:Obj) (b:Obj) (c:Obj)
    (f:Hom(?c, ?a)) (g:Hom(?c, ?b))
    -> Hom(?c, prod(?a, ?b));

  # Product β and η
  computational exl_pair :
    (a:Obj) (b:Obj) (c:Obj)
    (f:Hom(?c, ?a)) (g:Hom(?c, ?b)) |-
      comp(?c, prod(?a, ?b), ?a, exl(?a, ?b), pair(?a, ?b, ?c, ?f, ?g))
        -> ?f;

  computational exr_pair :
    (a:Obj) (b:Obj) (c:Obj)
    (f:Hom(?c, ?a)) (g:Hom(?c, ?b)) |-
      comp(?c, prod(?a, ?b), ?b, exr(?a, ?b), pair(?a, ?b, ?c, ?f, ?g))
        -> ?g;

  computational pair_eta :
    (a:Obj) (b:Obj) (c:Obj)
    (h:Hom(?c, prod(?a, ?b))) |-
      pair(?a, ?b, ?c,
           comp(?c, prod(?a, ?b), ?a, exl(?a, ?b), ?h),
           comp(?c, prod(?a, ?b), ?b, exr(?a, ?b), ?h))
        -> ?h;

  # Exponentials
  op exp : (a:Obj) (b:Obj) -> Obj;

  op curry :
    (a:Obj) (b:Obj) (c:Obj)
    (f:Hom(prod(?c, ?a), ?b))
    -> Hom(?c, exp(?a, ?b));

  op eval :
    (a:Obj) (b:Obj)
    -> Hom(prod(exp(?a, ?b), ?a), ?b);

  # Exponential β: eval ∘ <(curry f ∘ π1), π2> = f
  computational beta :
    (a:Obj) (b:Obj) (c:Obj)
    (f:Hom(prod(?c, ?a), ?b)) |-
      comp(prod(?c, ?a), prod(exp(?a, ?b), ?a), ?b,
           eval(?a, ?b),
           pair(exp(?a, ?b), ?a, prod(?c, ?a),
                comp(prod(?c, ?a), ?c, exp(?a, ?b),
                     curry(?a, ?b, ?c, ?f),
                     exl(?c, ?a)),
                exr(?c, ?a)))
        -> ?f;

  # Exponential η: curry(eval ∘ <(g ∘ π1), π2>) = g
  computational eta :
    (a:Obj) (b:Obj) (c:Obj)
    (g:Hom(?c, exp(?a, ?b))) |-
      curry(?a, ?b, ?c,
            comp(prod(?c, ?a), prod(exp(?a, ?b), ?a), ?b,
                 eval(?a, ?b),
                 pair(exp(?a, ?b), ?a, prod(?c, ?a),
                      comp(prod(?c, ?a), ?c, exp(?a, ?b), ?g, exl(?c, ?a)),
                      exr(?c, ?a))))
        -> ?g;
}

doctrine CCGen where {
  sort Obj;
  sort Hom(Obj, Obj);

  # repeat the core decls so we can mention them in types; And-merging will identify identical decls
  op Unit : Obj;
  op prod : (a:Obj) (b:Obj) -> Obj;
  op exp : (a:Obj) (b:Obj) -> Obj;

  op X : Obj;
  op A : Obj;
  op B : Obj;

  # a “program” to test β: f : X×A -> B
  op f : Hom(prod(X, A), B);
}

doctrine CCC = (CCCore@C) & (CCGen@C);
